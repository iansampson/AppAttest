//
//  API.swift
//  
//
//  Created by Ian Sampson on 2020-12-21.
//

import Foundation
import Crypto

/// A namespace for functions that verify attestations and assertions
/// generated by Apple’s App Attest service.
public enum AppAttest { }

// TODO: Add a landing page for DocC
// with a description of the package.


// MARK: - Attestation

extension AppAttest {
    /// A request to verify an attestation and its associated public key.
    ///
    /// `AttestationRequest` encapsulates the attestation submitted
    /// by a client app for verification.
    public struct AttestationRequest: Codable {
        /// The attestation object generated by the App Attest service.
        public let attestation: Data
        
        /// The public key identifier associated with the client app.
        public let keyID: Data
        
        /// Creates an `AttestationRequest` with the given attestation and key identifier.
        public init(attestation: Data, keyID: Data) {
            self.attestation = attestation
            self.keyID = keyID
        }
    }
    
    /// A verified attestation.
    ///
    /// The `verifyAttestation` function returns this result
    /// when attestation succeeds. Store the public key and receipt
    /// on your server for later use.
    public struct AttestationResult {
        /// The public key associated with the client app.
        public let publicKey: P256.Signing.PublicKey
        
        /// A receipt that can be used in a server-to-server call
        /// to request a fraud assessment metric from Apple.
        public let receipt: Data
    }
    
    /// Verifies an attestation generated by the App Attest service.
    ///
    /// - parameter challenge:
    /// The challenge previously generated and stored by the server
    /// in response to a request from the client app.
    ///
    /// - parameter request:
    /// A request that encapsulates the attestation submitted
    /// by a client app for verification.
    ///
    /// - parameter appID:
    /// The app identifier, which comprises
    /// the developer’s team identifier and the app’s bundle identifier.
    ///
    /// - parameter date:
    /// The date the attestation was generated.
    /// If `nil`, the current date is used.
    /// Only use this parameter for testing,
    /// and never trust a date submitted
    /// by the client app.
    ///
    /// - returns:
    /// A verified attestation, which contains a public key
    /// and a receipt that can be used for further verification.
    /// Store this result on your server for later use.
    public static func verifyAttestation(
        challenge: Data,
        request: AttestationRequest,
        appID: AppID,
        date: Date? = nil
    ) throws -> AttestationResult {
        let attestation = try Attestation(data: request.attestation)
        let certificate = attestation.statement.certificates[0]
        
        guard let publicKeyData = certificate.publicKey else {
            throw Attestation.ValidationError.invalidPublicKey
            // Or .missingPublicKey
        }
        let publicKey = try P256.Signing.PublicKey(x963Representation: publicKeyData)
        
        try attestation.verify(
            challenge: challenge,
            appID: appID.description,
            keyID: request.keyID,
            date: date
        )
        // TODO: Pass in publicKey as an argument.
        
        return AttestationResult(
            publicKey: publicKey,
            receipt: attestation.statement.receipt
        )
    }
}


// MARK: - Assertion

extension AppAttest {
    /// A request to verify an assertion and its associated client data.
    ///
    /// `AssertionRequest` encapsulates the assertion submitted
    /// by a client app for verification.
    public struct AssertionRequest: Codable {
        /// The assertion object generated by the App Attest service.
        public let assertion: Data
        
        /// The client data submitted alongside the assertion request.
        public let clientData: Data
        
        /// The challenge generated by the server in response
        /// to a request from the client app.
        public let challenge: Data
        // TODO: Disambiguate this instance of the challenge
        // from the one submitted in the `verifyAssertion` call.
        
        /// Creates an `AssertionRequest` with the given assertion object, client data, and challenge.
        public init(assertion: Data, clientData: Data, challenge: Data) {
            self.assertion = assertion
            self.clientData = clientData
            self.challenge = challenge
        }
    }
    // TODO: Consider namespacing this struct
    // Assertion.ClientResponse
    // Assertion.Challenge.Response
    // TODO: Correct readme, which omits challenge and clientData
    
    /// A verified assertion.
    ///
    /// The `verifyAssertion` function returns this result
    /// when assertion succeeds. Store the result on your server
    /// for subsequent calls to `verifyAssertion`.
    public struct AssertionResult {
        /// A value that reports the number of times your app has used the attested key to sign an assertion.
        /// The `verifyAssertion` function extracts this value from the authenticator data
        /// contained in the CBOR-assertion object and ensures that it is higher than the previous result.
        public let counter: Int
    }
    // TODO: Consider including an identifier
    // (for example, the public key identifier)
    // that will make it easier to store this result
    // and retrieve it later.
    // TODO: Either make `counter` public or make AssertionResult
    // conform to Codable so that it can be stored in a database.
    
    /// Verifies an assertion generated by the App Attest service.
    ///
    /// - parameter challenge:
    /// The challenge previously generated and stored by the server
    /// in response to a request from the client app.
    ///
    /// - parameter request:
    /// A request that encapsulates the assertion submitted
    /// by a client app for verification.
    ///
    /// - parameter previousResult:
    /// The result of the most recent assertion
    /// by this instance of the client app. If this is the first assertion,
    /// use `nil`.
    ///
    /// - parameter publicKey: The public key for this client app,
    /// returned by `verifyAttestation`.
    ///
    /// - parameter appID:
    /// The app identifier, which comprises
    /// the developer’s team identifier and the app’s bundle identifier.
    ///
    /// - returns:
    /// A verified attestation, which contains a public key
    /// and a receipt that can be used for further verification.
    /// Store this result on your server for later use.
    public static func verifyAssertion(
        challenge: Data,
        request: AssertionRequest,
        previousResult: AssertionResult?,
        publicKey: P256.Signing.PublicKey,
        appID: AppID
    ) throws -> AssertionResult {
        let assertion = try Assertion(cbor: request.assertion)
        try assertion.verify(
            clientData: request.clientData,
            publicKey: publicKey,
            appID: appID.description,
            previousCounter: previousResult?.counter,
            receivedChallenge: request.challenge,
            storedChallenge: challenge
        )
        return AssertionResult(counter: Int(assertion.authenticatorData.counter))
    }
    // TODO: Add a note in the documentation warning the user
    // to use a different challenge for attestation and assertion
    // (and to never reuse a challenge).
}

extension AppAttest {
    /// The app identifier for the client,
    /// composed of the developer’s team identifier
    /// and the app’s bundle identifier.
    public struct AppID: Codable {
        /// The developer’s unique team identifier,
        /// which can be found in App Store Connect.
        public let teamID: String
        
        /// The bundle identifier for the client app.
        public let bundleID: String
        
        /// A string representation of the app identifier,
        /// used during the verification process.
        var description: String {
            "\(teamID).\(bundleID)"
        }
        
        /// Creates an `AppID` from the given team identifier and bundle identifier.
        public init(teamID: String, bundleID: String) {
            self.teamID = teamID
            self.bundleID = bundleID
        }
    }
    // TODO: Allow initialization with a String
    // or StringLiteral.
}
